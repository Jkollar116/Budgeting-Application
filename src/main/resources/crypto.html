<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Crypto Wallet Manager</title>
    <link rel="stylesheet" href="style.css">

</head>
<body class = "crypto-page">
<header>
    <div class="logo">CashClimb</div>
    <nav>
        <ul>
            <li><a href="profile.html">Profile</a></li>
        </ul>
    </nav>
</header>
<button class="drawer-toggle" onclick="toggleDrawer()">â˜°</button>
<nav class="drawer" id="sideDrawer">
    <ul>
        <li><a href="home.html">Dashboard</a></li>
        <li><a href="expenses.html">Expenses</a></li>
        <li><a href="income.html">Income</a></li>
        <li><a href="crypto.html">Crypto</a></li>
        <li><a href="stocks.html">Stocks</a></li>
        <li><a href="chat.html">Chat</a></li>
        <li><a href="tax.html">Tax</a></li>
        <li><a href="bills.html">Bills</a></li>
        <li><a href="#">Profile</a></li>
        <li><a href="settings.html">Settings</a></li>
        <li><a href="index.html">Logout</a></li>
    </ul>
</nav>
<div class="dashboard">
    <!-- Portfolio Summary Section - More Compact -->
    <div class="card portfolio-section">
        <h2>Portfolio Summary</h2>
        <div class="portfolio-stats">
            <div class="stat">
                <span class="stat-label">Total Value</span>
                <span class="stat-value" id="total-value">$0.00</span>
            </div>
            <div class="stat">
                <span class="stat-label">24h Change</span>
                <span class="stat-value" id="total-change">0.00%</span>
            </div>
            <div class="stat">
                <span class="stat-label">Number of Wallets</span>
                <span class="stat-value" id="wallet-count">0</span>
            </div>
        </div>
        <div class="portfolio-chart">
            <canvas id="portfolio-chart"></canvas>
        </div>
    </div>

    <!-- Market Overview Section - Enhanced -->
    <div class="card market-section">
        <h2>Market Overview</h2>
        <div id="market-data">
            <!-- Market data will be inserted here via JavaScript -->
        </div>
    </div>

    <!-- Wallet Management Section - Side by Side -->
    <div class="card wallet-section">
        <div class="add-wallet-form">
            <h3>Add Custom Wallet</h3>
            <form id="custom-wallet-form">
                <input type="text" id="wallet-label" placeholder="Wallet Label" required>
                <input type="text" id="wallet-address" placeholder="Wallet Address" required>
                <select id="crypto-type" required>
                    <option value="">Select Cryptocurrency</option>
                    <option value="BTC">Bitcoin (BTC)</option>
                    <option value="ETH">Ethereum (ETH)</option>
                    <option value="USDT">Tether (USDT)</option>
                    <option value="BNB">Binance Coin (BNB)</option>
                    <option value="XRP">Ripple (XRP)</option>
                    <option value="ADA">Cardano (ADA)</option>
                    <option value="DOGE">Dogecoin (DOGE)</option>
                    <option value="SOL">Solana (SOL)</option>
                    <option value="DOT">Polkadot (DOT)</option>
                    <option value="AVAX">Avalanche (AVAX)</option>
                    <option value="MATIC">Polygon (MATIC)</option>
                    <option value="LINK">Chainlink (LINK)</option>
                </select>
                <button type="submit" class="btn">Add Wallet</button>
            </form>
        </div>
        <div class="test-buttons">
            <h3>Test Wallets</h3>
            <div class="btn-grid">
                <button id="add-btc-btn" class="btn">Add Test BTC</button>
                <button id="add-eth-btn" class="btn">Add Test ETH</button>
                <button id="refresh-all-btn" class="btn">Refresh All</button>
                <button id="clear-all-btn" class="btn">Clear All</button>
            </div>
        </div>
    </div>

    <!-- Wallet List Section - Bigger & More Prominent -->
    <div class="card wallets-list-section">
        <h2>Your Crypto Wallets</h2>
        <div id="error-container"></div>
        <div class="wallet-list" id="wallets-container">
            <!-- Wallet cards will be inserted here via JavaScript -->
        </div>
    </div>

    <!-- Analytics Section -->
    <div class="card analytics-section">
        <h2>Performance Analytics</h2>
        <select id="timeframe-selector" style="padding: 8px; border-radius: 5px; background: rgba(62, 31, 91, 0.7); color: white; border: 1px solid #FF8C00; margin-bottom: 10px;">
            <option value="24h">24 Hours</option>
            <option value="7d">7 Days</option>
            <option value="30d">30 Days</option>
            <option value="1y">1 Year</option>
        </select>
        <div class="chart-container">
            <canvas id="performance-chart"></canvas>
        </div>
        <div class="chart-container" style="margin-top: 15px;">
            <canvas id="distribution-chart"></canvas>
        </div>
    </div>
</div>

<!-- Scripts -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/qrcode-generator@1.4.4/qrcode.min.js"></script>

<script>
    function toggleDrawer() {
        const drawer = document.getElementById('sideDrawer');
        drawer.classList.toggle('collapsed');
    }
    function getThemePreference(name) {
        const match = document.cookie.match(new RegExp('(^| )' + name + '=([^;]+)'));
        if (!match) return null;
        return match[2];
    }
    window.addEventListener('DOMContentLoaded', () => {
        const savedTheme = getThemePreference('theme');
        const body = document.body;

        body.classList.remove('light-mode', 'dark-mode');
        if (savedTheme === 'light') {
            body.classList.add('light-mode');
        } else if (savedTheme === 'dark') {
            body.classList.add('dark-mode');
        }
    });
    // Constants and Variables
    const TEST_WALLETS = {
        BTC: [
            { address: "1GrwDkr33gT6LuumniYjKEGjTLhsL5kmqC", label: "Bitcoin Wallet 1" },
            { address: "1F3bs9gGZcZHHnWQq1EtuqoVBLnTaD9k1A", label: "Bitcoin Wallet 2" }
        ],
        ETH: [
            { address: "0xde0b295669a9fd93d5f28d9ec85e40f4cb697bae", label: "Ethereum Foundation" },
            { address: "0x742d35Cc6634C0532925a3b844Bc454e4438f44e", label: "Ethereum Whale" }
        ]
    };

    let currentBTCIndex = 0;
    let currentETHIndex = 0;
    let portfolioChart = null;
    let performanceChart = null;
    let distributionChart = null;

    // Initialize when document loads
    document.addEventListener('DOMContentLoaded', function() {
        const btcButton = document.getElementById('add-btc-btn');
        const ethButton = document.getElementById('add-eth-btn');
        const refreshButton = document.getElementById('refresh-all-btn');
        const clearButton = document.getElementById('clear-all-btn');
        const customWalletForm = document.getElementById('custom-wallet-form');

        btcButton.addEventListener('click', addTestBitcoinWallet);
        ethButton.addEventListener('click', addTestEthereumWallet);
        refreshButton.addEventListener('click', refreshAllWallets);
        clearButton.addEventListener('click', clearAllWallets);

        customWalletForm.addEventListener('submit', function(e) {
            e.preventDefault();
            const label = document.getElementById('wallet-label').value;
            const address = document.getElementById('wallet-address').value;
            const cryptoType = document.getElementById('crypto-type').value;

            addWallet(label, address, cryptoType);
            customWalletForm.reset();
        });

        // Initial loads
        loadWallets();
        loadMarketData();
        initializeAnalytics();
    });

    // Wallet Management Functions
    function addWallet(label, address, cryptoType) {
        console.log(`Adding wallet: ${label}, ${address}, ${cryptoType}`);

        const newWallet = {
            id: Date.now().toString(), // Add unique ID for each wallet
            label: label,
            address: address,
            cryptoType: cryptoType,
            balance: cryptoType === 'BTC' ? 3084.31624354 : 150.45678912,
            value: cryptoType === 'BTC' ? 290852227.31 : 450678.23,
            change24h: cryptoType === 'BTC' ? -1.38 : 2.45,
            lastUpdated: new Date().toISOString()
        };

        let wallets = JSON.parse(localStorage.getItem('wallets') || '[]');

        // Check for duplicate address
        if (wallets.some(w => w.address === address)) {
            showError('Wallet with this address already exists');
            return;
        }

        wallets.push(newWallet);
        localStorage.setItem('wallets', JSON.stringify(wallets));
        loadWallets();

        // Show success message
        showMessage(`Added ${cryptoType} wallet: ${label}`);
    }

    function loadWallets() {
        const wallets = JSON.parse(localStorage.getItem('wallets') || '[]');
        updatePortfolioSummary(wallets);
        updateWalletsDisplay(wallets);
        updateAnalytics(wallets);
    }

    function updateWalletsDisplay(wallets) {
        const container = document.getElementById('wallets-container');
        container.innerHTML = '';

        if (wallets.length === 0) {
            container.innerHTML = '<div style="text-align: center; padding: 30px; color: rgba(255,255,255,0.7);">No wallets added. Add a wallet to get started.</div>';
            return;
        }

        wallets.forEach(wallet => {
            const card = createWalletCard(wallet);
            container.appendChild(card);
        });
    }

    function createWalletCard(wallet) {
        const div = document.createElement('div');
        div.className = 'wallet-card';

        const formattedValue = new Intl.NumberFormat('en-US', {
            style: 'currency',
            currency: 'USD'
        }).format(wallet.value);

        const formattedBalance = new Intl.NumberFormat('en-US', {
            minimumFractionDigits: 8,
            maximumFractionDigits: 8
        }).format(wallet.balance);

        const changeClass = wallet.change24h >= 0 ? 'positive' : 'negative';

        div.innerHTML = `
            <div class="wallet-header">
                <h3>${wallet.label}</h3>
                <span class="wallet-type">${wallet.cryptoType}</span>
            </div>
            <div class="wallet-info">
                <div class="wallet-info-item">
                    <span class="label">Balance</span>
                    <span class="value">${formattedBalance} ${wallet.cryptoType}</span>
                </div>
                <div class="wallet-info-item">
                    <span class="label">Value</span>
                    <span class="value">${formattedValue}</span>
                </div>
                <div class="wallet-info-item">
                    <span class="label">Address</span>
                    <span class="value" style="font-size: 0.85em;">${formatAddress(wallet.address)}</span>
                </div>
                <div class="wallet-info-item">
                    <span class="label">24h Change</span>
                    <span class="value ${changeClass}">${wallet.change24h.toFixed(2)}%</span>
                </div>
            </div>
            <div class="wallet-actions">
                <button onclick="refreshWallet('${wallet.id}')" class="btn btn-small">Refresh</button>
                <button onclick="showQRCode('${wallet.address}')" class="btn btn-small">QR Code</button>
                <button onclick="deleteWallet('${wallet.id}')" class="btn btn-small">Delete</button>
            </div>
        `;
        return div;
    }

    function formatAddress(address) {
        if (!address) return '';
        if (address.length <= 15) return address;
        return address.substring(0, 8) + '...' + address.substring(address.length - 8);
    }

    function refreshWallet(id) {
        let wallets = JSON.parse(localStorage.getItem('wallets') || '[]');
        const wallet = wallets.find(w => w.id === id);
        
        if (!wallet) {
            showError("Wallet not found");
            return;
        }
        
        showMessage("Fetching real-time data...");
        
        // Create API URL to fetch wallet data from our backend
        const apiUrl = `/api/wallet?address=${encodeURIComponent(wallet.address)}&type=${encodeURIComponent(wallet.cryptoType)}`;
        
        fetch(apiUrl)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`API call failed: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                // Update wallet with real data from API
                wallet.balance = data.balance;
                wallet.value = data.value;
                wallet.change24h = data.change24h;
                wallet.lastUpdated = new Date().toISOString();
                
                if (data.transactions && data.transactions.length > 0) {
                    wallet.transactions = data.transactions;
                }
                
                // Save updated wallets
                wallets = wallets.map(w => w.id === id ? wallet : w);
                localStorage.setItem('wallets', JSON.stringify(wallets));
                loadWallets();
                
                showMessage("Wallet updated with real-time data");
            })
            .catch(error => {
                console.error("Error refreshing wallet:", error);
                
                // Fallback to simulated update if API fails
                const changePercent = (Math.random() * 4) - 2;
                wallet.value = wallet.value * (1 + (changePercent / 100));
                wallet.change24h = changePercent;
                wallet.lastUpdated = new Date().toISOString();
                
                wallets = wallets.map(w => w.id === id ? wallet : w);
                localStorage.setItem('wallets', JSON.stringify(wallets));
                loadWallets();
                
                showMessage("Wallet refreshed (using simulated data)");
            });
    }

    function deleteWallet(id) {
        if (!confirm('Are you sure you want to delete this wallet?')) return;

        let wallets = JSON.parse(localStorage.getItem('wallets') || '[]');
        const walletToDelete = wallets.find(w => w.id === id);
        wallets = wallets.filter(w => w.id !== id);
        localStorage.setItem('wallets', JSON.stringify(wallets));
        loadWallets();

        // Show a quick notification
        showMessage(`${walletToDelete.cryptoType} wallet deleted`);
    }

    // Portfolio Summary Functions
    function updatePortfolioSummary(wallets) {
        const totalValue = wallets.reduce((sum, wallet) => sum + (wallet.value || 0), 0);
        let avgChange = 0;

        if (wallets.length > 0) {
            // Weighted average change based on value
            avgChange = wallets.reduce((sum, wallet) => {
                return sum + (wallet.change24h || 0) * (wallet.value / totalValue);
            }, 0);
        }

        const totalValueElem = document.getElementById('total-value');
        const totalChangeElem = document.getElementById('total-change');
        const walletCountElem = document.getElementById('wallet-count');

        totalValueElem.textContent = new Intl.NumberFormat('en-US', {
            style: 'currency',
            currency: 'USD'
        }).format(totalValue);

        totalChangeElem.textContent = `${avgChange.toFixed(2)}%`;
        totalChangeElem.className = 'stat-value ' + (avgChange >= 0 ? 'positive' : 'negative');

        walletCountElem.textContent = wallets.length;

        updatePortfolioChart(wallets);
    }

    function updatePortfolioChart(wallets) {
        const ctx = document.getElementById('portfolio-chart').getContext('2d');

        if (portfolioChart) {
            portfolioChart.destroy();
        }

        if (wallets.length === 0) {
            ctx.font = '14px Arial';
            ctx.fillStyle = 'rgba(255,255,255,0.7)';
            ctx.textAlign = 'center';
            ctx.fillText('No wallet data to display', ctx.canvas.width/2, ctx.canvas.height/2);
            return;
        }

        portfolioChart = new Chart(ctx, {
            type: 'doughnut',
            data: {
                labels: wallets.map(w => `${w.label} (${w.cryptoType})`),
                datasets: [{
                    data: wallets.map(w => w.value),
                    backgroundColor: [
                        '#FF8C00', '#1E90FF', '#32CD32', '#FF69B4', '#9370DB',
                        '#20B2AA', '#F08080', '#DEB887', '#87CEEB', '#DDA0DD'
                    ],
                    borderWidth: 2,
                    borderColor: '#3E1F5B'
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false  // Hide legend to save space
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const label = context.label || '';
                                const value = context.formattedValue;
                                return `${label}: ${value}`;
                            }
                        }
                    }
                },
                cutout: '70%',
                radius: '90%'
            }
        });
    }

    // Helper Functions
    function showError(message) {
        const errorContainer = document.getElementById('error-container');
        const errorDiv = document.createElement('div');
        errorDiv.className = 'error-message';
        errorDiv.textContent = message;
        errorContainer.appendChild(errorDiv);

        setTimeout(() => {
            errorDiv.style.opacity = '0';
            errorDiv.style.transition = 'opacity 0.5s ease';
            setTimeout(() => {
                errorDiv.remove();
            }, 500);
        }, 4000);
    }

    function showMessage(message) {
        const msgDiv = document.createElement('div');
        msgDiv.style.position = 'fixed';
        msgDiv.style.top = '20px';
        msgDiv.style.right = '20px';
        msgDiv.style.backgroundColor = 'rgba(50, 205, 50, 0.9)';
        msgDiv.style.color = 'white';
        msgDiv.style.padding = '10px 20px';
        msgDiv.style.borderRadius = '5px';
        msgDiv.style.boxShadow = '0 2px 10px rgba(0,0,0,0.3)';
        msgDiv.style.zIndex = '1000';
        msgDiv.textContent = message;

        document.body.appendChild(msgDiv);

        setTimeout(() => {
            msgDiv.style.opacity = '0';
            msgDiv.style.transition = 'opacity 0.5s ease';
            setTimeout(() => msgDiv.remove(), 500);
        }, 2000);
    }

    function clearAllWallets() {
        if (confirm('Are you sure you want to clear all wallets?')) {
            localStorage.removeItem('wallets');
            loadWallets();
            showMessage("All wallets were cleared");
        }
    }

    // Test Wallet Functions
    function addTestBitcoinWallet() {
        // Generate a different test wallet each time
        const wallet = TEST_WALLETS.BTC[currentBTCIndex % TEST_WALLETS.BTC.length];
        currentBTCIndex++;
        
        // Add unique suffix to make the address unique each time
        const uniqueAddress = wallet.address + "-" + Date.now().toString().substr(-6);
        addWallet(wallet.label + " " + currentBTCIndex, uniqueAddress, "BTC");
    }

    function addTestEthereumWallet() {
        // Generate a different test wallet each time
        const wallet = TEST_WALLETS.ETH[currentETHIndex % TEST_WALLETS.ETH.length];
        currentETHIndex++;
        
        // Add unique suffix to make the address unique each time
        const uniqueAddress = wallet.address + "-" + Date.now().toString().substr(-6);
        addWallet(wallet.label + " " + currentETHIndex, uniqueAddress, "ETH");
    }

    function refreshAllWallets() {
        let wallets = JSON.parse(localStorage.getItem('wallets') || '[]');

        if (wallets.length === 0) {
            showError("No wallets to refresh");
            return;
        }

        wallets.forEach(wallet => {
            const changePercent = (Math.random() * 4) - 2; // Random change between -2% and 2%
            wallet.value = wallet.value * (1 + (changePercent / 100));
            wallet.change24h = changePercent;
            wallet.lastUpdated = new Date().toISOString();
        });

        localStorage.setItem('wallets', JSON.stringify(wallets));
        loadWallets();
        showMessage(`Refreshed ${wallets.length} wallets`);
    }

    // Market Data Implementation - Fetches real data from APIs with fallback
    function loadMarketData() {
        const marketDataDiv = document.getElementById('market-data');
        marketDataDiv.innerHTML = '<div style="text-align: center; padding: 20px;">Loading market data...</div>';

        // Fallback data for when API calls fail
        const fallbackData = {
            BTC: {
                currentPrice: 68452.75,
                priceChange24h: 2.34,
                marketCap: 1330000000000,
                volume24h: 46000000000
            },
            ETH: {
                currentPrice: 3890.42,
                priceChange24h: 1.76,
                marketCap: 467000000000,
                volume24h: 21000000000
            }
        };

        // Create API URLs to fetch market data from our backend
        const btcApiUrl = `/api/wallet?type=BTC`;
        const ethApiUrl = `/api/wallet?type=ETH`;
        
        // Keep track of successful API calls
        let btcDataFetched = false;
        let ethDataFetched = false;
        let btcData, ethData;
        
        // Function to display market data once both crypto data points are available
        // (either from API or fallback)
        function displayMarketData() {
            if (btcData && ethData) {
                marketDataDiv.innerHTML = ''; // Clear loading message
                marketDataDiv.appendChild(createCryptoMarketCard('Bitcoin (BTC)', btcData));
                marketDataDiv.appendChild(createCryptoMarketCard('Ethereum (ETH)', ethData));
                createTrendChart();
                
                // If we're using fallback data, show a notice
                if (!btcDataFetched || !ethDataFetched) {
                    const fallbackNotice = document.createElement('div');
                    fallbackNotice.className = 'market-card';
                    fallbackNotice.innerHTML = `
                        <div style="font-size: 0.8em; color: #FFA500; text-align: center; padding: 5px;">
                            <i>Using cached market data. Real-time updates unavailable.</i>
                        </div>
                    `;
                    marketDataDiv.appendChild(fallbackNotice);
                }
            }
        }
        
        // Fetch BTC market data with timeout and fallback
        const btcPromise = new Promise((resolve) => {
            const timeoutId = setTimeout(() => {
                console.log("BTC data fetch timed out, using fallback");
                resolve({ useFallback: true });
            }, 5000); // 5 second timeout
            
            fetch(btcApiUrl)
                .then(response => {
                    clearTimeout(timeoutId);
                    if (!response.ok) {
                        throw new Error(`API call failed: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    resolve({ useFallback: false, data: data });
                })
                .catch(error => {
                    clearTimeout(timeoutId);
                    console.error("Error fetching BTC data:", error);
                    resolve({ useFallback: true });
                });
        });
        
        // Fetch ETH market data with timeout and fallback
        const ethPromise = new Promise((resolve) => {
            const timeoutId = setTimeout(() => {
                console.log("ETH data fetch timed out, using fallback");
                resolve({ useFallback: true });
            }, 5000); // 5 second timeout
            
            fetch(ethApiUrl)
                .then(response => {
                    clearTimeout(timeoutId);
                    if (!response.ok) {
                        throw new Error(`API call failed: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    resolve({ useFallback: false, data: data });
                })
                .catch(error => {
                    clearTimeout(timeoutId);
                    console.error("Error fetching ETH data:", error);
                    resolve({ useFallback: true });
                });
        });
        
        // Process BTC data
        btcPromise.then(result => {
            if (result.useFallback) {
                btcData = fallbackData.BTC;
                btcDataFetched = false;
            } else {
                btcData = result.data;
                btcDataFetched = true;
            }
            displayMarketData();
        });
        
        // Process ETH data
        ethPromise.then(result => {
            if (result.useFallback) {
                ethData = fallbackData.ETH;
                ethDataFetched = false;
            } else {
                ethData = result.data;
                ethDataFetched = true;
            }
            displayMarketData();
        });
    }
    
    // Helper function to create a crypto market card - enhanced with error handling
    function createCryptoMarketCard(name, data) {
        const card = document.createElement('div');
        card.className = 'market-card';
        
        // Extract price data from API response with fallbacks for any missing fields
        const price = data.currentPrice !== undefined ? data.currentPrice : 0;
        const change24h = data.priceChange24h !== undefined ? data.priceChange24h : 0;
        
        // Use provided market cap and volume if available, otherwise calculate
        let marketCap, volume24h;
        
        if (data.marketCap !== undefined) {
            marketCap = data.marketCap;
        } else {
            // Fallback calculation
            marketCap = price * (name.includes('BTC') ? 19000000 : 120000000);
        }
        
        if (data.volume24h !== undefined) {
            volume24h = data.volume24h;
        } else {
            // Fallback calculation
            volume24h = marketCap * 0.05;
        }
        
        // Add a subtle animation to draw attention to the card
        card.style.animation = 'fadeIn 0.5s ease-in';
        
        card.innerHTML = `
            <h3>${name}</h3>
            <div class="market-stat">
                <span>Price</span>
                <span>${formatCurrency(price)}</span>
            </div>
            <div class="market-stat">
                <span>24h Change</span>
                <span class="${change24h >= 0 ? 'positive' : 'negative'}">${change24h.toFixed(2)}%</span>
            </div>
            <div class="market-stat">
                <span>Market Cap</span>
                <span>${formatLargeNumber(marketCap)}</span>
            </div>
            <div class="market-stat">
                <span>24h Volume</span>
                <span>${formatLargeNumber(volume24h)}</span>
            </div>
        `;
        
        return card;
    }

    // Function to create trend chart with improved robustness
    function createTrendChart() {
        try {
            // Create chart container
            const marketDataDiv = document.getElementById('market-data');
            const trendContainer = document.createElement('div');
            trendContainer.style.marginTop = '15px';
            trendContainer.style.height = '120px';
            trendContainer.innerHTML = '<canvas id="trend-chart"></canvas>';
            marketDataDiv.appendChild(trendContainer);
    
            // Try to get data from multiple sources, with fallbacks at each step
            
            // 1. Try market data from DOM
            let btcPrice = 0;
            let ethPrice = 0;
            
            try {
                const btcCard = marketDataDiv.querySelector('.market-card:first-child');
                const ethCard = marketDataDiv.querySelector('.market-card:nth-child(2)');
                
                if (btcCard && ethCard) {
                    const btcPriceText = btcCard.querySelector('.market-stat:first-child span:last-child').textContent;
                    const ethPriceText = ethCard.querySelector('.market-stat:first-child span:last-child').textContent;
                    
                    // Extract numeric value from currency string (e.g. "$65,432.10" -> 65432.10)
                    btcPrice = parseFloat(btcPriceText.replace(/[^0-9.]/g, ''));
                    ethPrice = parseFloat(ethPriceText.replace(/[^0-9.]/g, ''));
                }
            } catch (e) {
                console.warn("Could not extract prices from DOM:", e);
            }
            
            // 2. If DOM extraction failed, try wallet collection
            if (!btcPrice || !ethPrice) {
                const wallets = JSON.parse(localStorage.getItem('wallets') || '[]');
                const btcWallets = wallets.filter(w => w.cryptoType === 'BTC');
                const ethWallets = wallets.filter(w => w.cryptoType === 'ETH');
                
                if (btcWallets.length > 0 && btcPrice === 0) {
                    btcPrice = btcWallets[0].value / btcWallets[0].balance;
                }
                
                if (ethWallets.length > 0 && ethPrice === 0) {
                    ethPrice = ethWallets[0].value / ethWallets[0].balance;
                }
            }
            
            // 3. Final fallback - use reasonable values if all else fails
            if (!btcPrice || btcPrice === 0) {
                btcPrice = 68452.75;
            }
            
            if (!ethPrice || ethPrice === 0) {
                ethPrice = 3890.42;
            }
                
            // Generate trend data based on prices
            const hours = Array.from({length: 24}, (_, i) => `${i}h`);
            
            // Use more realistic trend generation
            // Start with yesterday's price and work forward to today's price
            // For BTC (more volatile)
            let lastBtcPrice = btcPrice * 0.97; // Start 3% lower than current
            const btcTrend = [];
            for (let i = 0; i < 24; i++) {
                // More realistic hourly movements
                const hourlyChange = (Math.random() * 0.015) - 0.007; // -0.7% to +0.7%
                lastBtcPrice = lastBtcPrice * (1 + hourlyChange);
                
                // Gradual trend toward current price
                const currentPricePull = (btcPrice - lastBtcPrice) * (i / 120); // Gentle pull toward target
                lastBtcPrice += currentPricePull;
                
                btcTrend.push(lastBtcPrice);
            }
            
            // For ETH (less volatile than BTC)
            let lastEthPrice = ethPrice * 0.98; // Start 2% lower than current
            const ethTrend = [];
            for (let i = 0; i < 24; i++) {
                // More realistic hourly movements
                const hourlyChange = (Math.random() * 0.01) - 0.005; // -0.5% to +0.5%
                lastEthPrice = lastEthPrice * (1 + hourlyChange);
                
                // Gradual trend toward current price
                const currentPricePull = (ethPrice - lastEthPrice) * (i / 150); // Gentle pull toward target
                lastEthPrice += currentPricePull;
                
                ethTrend.push(lastEthPrice);
            }
            
            // Create the chart
            const trendCtx = document.getElementById('trend-chart').getContext('2d');
            new Chart(trendCtx, {
                type: 'line',
                data: {
                    labels: hours,
                    datasets: [
                        {
                            label: 'BTC',
                            data: btcTrend,
                            borderColor: '#FF8C00',
                            backgroundColor: 'rgba(255, 140, 0, 0.1)',
                            borderWidth: 2,
                            tension: 0.4,
                            yAxisID: 'y-btc'
                        },
                        {
                            label: 'ETH',
                            data: ethTrend,
                            borderColor: '#1E90FF',
                            backgroundColor: 'rgba(30, 144, 255, 0.1)',
                            borderWidth: 2,
                            tension: 0.4,
                            yAxisID: 'y-eth'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                            labels: {
                                color: 'white',
                                boxWidth: 15,
                                padding: 10
                            }
                        },
                        title: {
                            display: true,
                            text: '24h Price Trends',
                            color: 'white',
                            font: {
                                size: 14
                            }
                        }
                    },
                    scales: {
                        x: {
                            display: false
                        },
                        'y-btc': {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            ticks: {
                                callback: function(value) {
                                    return '$' + parseInt(value).toLocaleString();
                                },
                                color: '#FF8C00'
                            },
                            grid: {
                                display: false
                            }
                        },
                        'y-eth': {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            ticks: {
                                callback: function(value) {
                                    return '$' + parseInt(value).toLocaleString();
                                },
                                color: '#1E90FF'
                            },
                            grid: {
                                display: false
                            }
                        }
                    }
                }
            });
        } catch (error) {
            console.error("Error creating trend chart:", error);
            
            // Add error recovery - insert a simplified no-chart message if chart creation fails
            const marketDataDiv = document.getElementById('market-data');
            const errorNotice = document.createElement('div');
            errorNotice.className = 'market-card';
            errorNotice.innerHTML = `
                <div style="text-align: center; padding: 10px;">
                    <p>Price trend chart unavailable</p>
                    <button id="retry-chart-btn" class="btn btn-small">Retry</button>
                </div>
            `;
            marketDataDiv.appendChild(errorNotice);
            
            // Add retry button functionality
            document.getElementById('retry-chart-btn').addEventListener('click', function() {
                this.textContent = 'Retrying...';
                setTimeout(() => {
                    try {
                        // Remove error message
                        errorNotice.remove();
                        // Try to create chart again
                        createTrendChart();
                    } catch (e) {
                        console.error("Retry failed:", e);
                    }
                }, 500);
            });
        }
    }

    // Analytics Implementation
    function initializeAnalytics() {
        document.getElementById('timeframe-selector').addEventListener('change', updateAnalytics);
        updateAnalytics();
    }

    function updateAnalytics() {
        const wallets = JSON.parse(localStorage.getItem('wallets') || '[]');
        updatePerformanceChart(wallets);
        updateDistributionChart(wallets);
    }

    function updatePerformanceChart(wallets) {
        const ctx = document.getElementById('performance-chart').getContext('2d');

        if (performanceChart) {
            performanceChart.destroy();
        }

        if (wallets.length === 0) {
            ctx.font = '14px Arial';
            ctx.fillStyle = 'rgba(255,255,255,0.7)';
            ctx.textAlign = 'center';
            ctx.fillText('No wallet data to display', ctx.canvas.width/2, ctx.canvas.height/2);
            return;
        }

        // Generate mock historical data
        const timeframe = document.getElementById('timeframe-selector').value;
        const dataPoints = timeframe === '24h' ? 24 : timeframe === '7d' ? 7 : timeframe === '30d' ? 30 : 12;
        const labels = Array.from({length: dataPoints}, (_, i) => {
            if (timeframe === '24h') return `${23-i}h ago`;
            if (timeframe === '7d') return `${6-i}d ago`;
            if (timeframe === '30d') return `${29-i}d ago`;
            return `${11-i}mo ago`;
        }).reverse();

        const totalValue = wallets.reduce((sum, wallet) => sum + wallet.value, 0);
        const values = [];

        // Create more realistic trend data
        let currentValue = totalValue * 0.85; // Start lower than current
        for (let i = 0; i < dataPoints; i++) {
            // Gradual uptrend with random noise
            const growthFactor = 1 + (Math.random() * 0.03);
            currentValue *= growthFactor;

            // Add some realistic volatility
            const volatility = Math.random() * 0.05 - 0.025;
            values.push(currentValue * (1 + volatility));
        }

        performanceChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: [{
                    label: 'Portfolio Value',
                    data: values,
                    borderColor: '#FF8C00',
                    backgroundColor: 'rgba(255, 140, 0, 0.1)',
                    fill: true,
                    tension: 0.4
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return 'Value: ' + formatCurrency(context.parsed.y);
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        ticks: {
                            callback: function(value) {
                                return formatCurrency(value);
                            },
                            color: 'rgba(255, 255, 255, 0.7)'
                        },
                        grid: {
                            color: 'rgba(255, 255, 255, 0.05)'
                        }
                    },
                    x: {
                        ticks: {
                            color: 'rgba(255, 255, 255, 0.7)',
                            maxRotation: 45,
                            minRotation: 45,
                            font: {
                                size: 10
                            }
                        },
                        grid: {
                            display: false
                        }
                    }
                }
            }
        });
    }

    function updateDistributionChart(wallets) {
        const ctx = document.getElementById('distribution-chart').getContext('2d');

        if (distributionChart) {
            distributionChart.destroy();
        }

        if (wallets.length === 0) {
            ctx.font = '14px Arial';
            ctx.fillStyle = 'rgba(255,255,255,0.7)';
            ctx.textAlign = 'center';
            ctx.fillText('No wallet data to display', ctx.canvas.width/2, ctx.canvas.height/2);
            return;
        }

        // Group by crypto type
        const btcValue = wallets.filter(w => w.cryptoType === 'BTC').reduce((sum, w) => sum + w.value, 0);
        const ethValue = wallets.filter(w => w.cryptoType === 'ETH').reduce((sum, w) => sum + w.value, 0);

        const totalValue = btcValue + ethValue;
        const btcPercent = totalValue > 0 ? ((btcValue / totalValue) * 100).toFixed(1) : 0;
        const ethPercent = totalValue > 0 ? ((ethValue / totalValue) * 100).toFixed(1) : 0;

        distributionChart = new Chart(ctx, {
            type: 'pie',
            data: {
                labels: [`BTC (${btcPercent}%)`, `ETH (${ethPercent}%)`],
                datasets: [{
                    data: [btcValue, ethValue],
                    backgroundColor: ['#FF8C00', '#1E90FF'],
                    borderWidth: 2,
                    borderColor: '#3E1F5B'
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'right',
                        labels: {
                            color: '#fff',
                            font: {
                                size: 12
                            },
                            padding: 15
                        }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return `${context.label}: ${formatCurrency(context.raw)}`;
                            }
                        }
                    }
                }
            }
        });
    }

    // QR Code Implementation with real-time uniqueness verification
    function showQRCode(address) {
        console.log("Generating QR code for address:", address);
        
        // Generate a truly unique QR code with multiple uniqueness factors
        // 1. Address
        // 2. Current timestamp (milliseconds)
        // 3. Random nonce
        const uniqueNonce = Math.random().toString(36).substring(2, 15);
        const uniqueData = `${address}?timestamp=${Date.now()}&nonce=${uniqueNonce}`;
        console.log("Generated unique QR data with nonce:", uniqueNonce);
        
        // Use a higher error correction level for better scanning
        const qr = qrcode(0, 'H');
        qr.addData(uniqueData);
        qr.make();
        
        // Create timestamp to display generation time
        const timestamp = new Date().toISOString();
        
        // Create modal with unique ID based on timestamp and nonce
        const modalId = `qr-modal-${Date.now()}-${uniqueNonce}`;
        const modal = document.createElement('div');
        modal.id = modalId;
        modal.className = 'qr-modal';

        // Create content with unique data and verification info
        modal.innerHTML = `
            <div class="qr-content">
                <h3>Wallet QR Code</h3>
                <div class="qr-code">${qr.createImgTag(5)}</div>
                <p style="word-break: break-all; font-size: 0.9em; margin-bottom: 15px;">${address}</p>
                <p style="font-size: 0.7em; color: rgba(255,255,255,0.5);">Generated: ${timestamp}</p>
                <p style="font-size: 0.7em; color: rgba(255,255,255,0.5);">Unique ID: ${Date.now().toString(36)}</p>
                <button class="btn">Close</button>
            </div>
        `;

        // Add click event to close modal
        modal.querySelector('button').addEventListener('click', () => {
            modal.style.opacity = '0';
            modal.style.transition = 'opacity 0.3s ease';
            setTimeout(() => modal.remove(), 300);
        });

        // Add modal to the page
        document.body.appendChild(modal);

        // Close when clicking outside content
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                modal.style.opacity = '0';
                modal.style.transition = 'opacity 0.3s ease';
                setTimeout(() => modal.remove(), 300);
            }
        });
    }

    // Utility Functions
    function formatCurrency(value) {
        return new Intl.NumberFormat('en-US', {
            style: 'currency',
            currency: 'USD',
            minimumFractionDigits: 2,
            maximumFractionDigits: 2
        }).format(value);
    }

    function formatLargeNumber(value) {
        if (value >= 1e12) return (value / 1e12).toFixed(2) + 'T';
        if (value >= 1e9) return (value / 1e9).toFixed(2) + 'B';
        if (value >= 1e6) return (value / 1e6).toFixed(2) + 'M';
        return value.toLocaleString();
    }
</script>

</body>
</html>
